<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Color Speech Practice</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 2rem;
    }
    #color-boxes {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    .color-box {
      width: 100px;
      height: 100px;
      border: 2px solid #000;
    }
    #spoken-result {
      margin-top: 1rem;
      font-size: 1.2rem;
    }
    #stats {
      margin-top: 1rem;
      padding: 1rem;
      background-color: #f0f0f0;
      border-radius: 5px;
    }
    label, input {
      margin: 0.5rem;
    }
    .correct {
      color: green;
    }
    .incorrect {
      color: red;
    }
  </style>
</head>
<body>
  <h1>Color Speech Trainer</h1>
  <label for="interval">Display Time (1â€“10 seconds):</label>
  <input type="number" id="interval" value="3" min="1" max="10" /> seconds
  <div id="color-boxes"></div>
  <button onclick="startGame()">Start</button>
  <div id="spoken-result"></div>
  <div id="stats">
    <h3>Statistics</h3>
    <p>Correct: <span id="correct-count">0</span></p>
    <p>Incorrect: <span id="incorrect-count">0</span></p>
    <p>Accuracy: <span id="accuracy">0%</span></p>
  </div>

  <script>
    // Expanded color list with variations
    const colors = [
      // Reds
      "red", "darkred", "firebrick", "crimson", "tomato", "indianred", "lightcoral",
      // Greens
      "green", "darkgreen", "forestgreen", "lime", "limegreen", "seagreen", "mediumseagreen",
      "springgreen", "olivedrab", "darkolivegreen", "yellowgreen", "lawngreen", "lightgreen",
      "palegreen", "mediumspringgreen",
      // Blues
      "blue", "darkblue", "mediumblue", "navy", "midnightblue", "royalblue", "cornflowerblue",
      "dodgerblue", "deepskyblue", "lightblue", "skyblue", "steelblue", "lightsteelblue",
      // Yellows/Oranges
      "yellow", "gold", "lightyellow", "lemonchiffon", "orange", "darkorange", "coral",
      // Purples
      "purple", "darkmagenta", "mediumpurple", "blueviolet", "darkviolet", "mediumorchid",
      "orchid", "violet", "plum", "thistle",
      // Others
      "pink", "brown", "black", "white", "gray", "silver", "aqua", "turquoise", "teal"
    ];
    
    // Color groups for flexible matching
    const colorGroups = {
      "red": ["red", "darkred", "firebrick", "crimson", "tomato", "indianred", "lightcoral"],
      "green": ["green", "darkgreen", "forestgreen", "seagreen", "darkolivegreen", "olivedrab"],
      "light green": ["lime", "limegreen", "mediumseagreen", "springgreen", "yellowgreen", 
                     "lawngreen", "lightgreen", "palegreen", "mediumspringgreen"],
      "blue": ["blue", "darkblue", "mediumblue", "navy", "midnightblue", "royalblue"],
      "light blue": ["cornflowerblue", "dodgerblue", "deepskyblue", "lightblue", "skyblue", 
                    "steelblue", "lightsteelblue"],
      "yellow": ["yellow", "gold", "lightyellow", "lemonchiffon"],
      "orange": ["orange", "darkorange", "coral"],
      "purple": ["purple", "darkmagenta", "mediumpurple", "blueviolet", "darkviolet"],
      "light purple": ["mediumorchid", "orchid", "violet", "plum", "thistle"],
      "pink": ["pink"],
      "brown": ["brown"],
      "black": ["black"],
      "white": ["white"],
      "gray": ["gray", "silver"],
      "aqua": ["aqua", "turquoise", "teal"]
    };
    
    let currentColors = [];
    let intervalId;
    let correctCount = 0;
    let incorrectCount = 0;
    let totalAttempts = 0;

    function getRandomColors(count = 3) {
      const shuffled = [...colors].sort(() => 0.5 - Math.random());
      return shuffled.slice(0, count);
    }

    function showColors() {
      const container = document.getElementById("color-boxes");
      container.innerHTML = "";
      currentColors = getRandomColors();

      currentColors.forEach(color => {
        const box = document.createElement("div");
        box.className = "color-box";
        box.style.backgroundColor = color;
        container.appendChild(box);
      });

      startSpeechRecognition();
    }

    function startGame() {
      // Reset statistics
      correctCount = 0;
      incorrectCount = 0;
      totalAttempts = 0;
      updateStats();
      
      clearInterval(intervalId);
      const seconds = Math.max(1, Math.min(10, parseInt(document.getElementById("interval").value)));
      showColors();
      intervalId = setInterval(showColors, seconds * 1000);
    }

    function findMatchingColorGroup(spokenColor) {
      for (const [groupName, groupColors] of Object.entries(colorGroups)) {
        if (groupColors.some(color => spokenColor.includes(color))) {
          return groupName;
        }
      }
      return null;
    }

    function startSpeechRecognition() {
      const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      recognition.lang = "en-US";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;

      recognition.onresult = (event) => {
        const spoken = event.results[0][0].transcript.toLowerCase();
        let matchedColors = [];
        let correctMatches = 0;
        
        // Check for both exact matches and group matches
        currentColors.forEach(color => {
          // Try to find the base color group
          let foundGroup = null;
          for (const [groupName, groupColors] of Object.entries(colorGroups)) {
            if (groupColors.includes(color)) {
              foundGroup = groupName;
              break;
            }
          }
          
          // Check if spoken text matches either the exact color or its group
          if (spoken.includes(color) || 
              (foundGroup && spoken.includes(foundGroup))) {
            matchedColors.push(color);
            correctMatches++;
          }
        });
        
        // Update statistics
        totalAttempts += currentColors.length;
        correctCount += correctMatches;
        incorrectCount += (currentColors.length - correctMatches);
        updateStats();
        
        // Display results with color coding
        const resultDiv = document.getElementById("spoken-result");
        resultDiv.innerHTML = `You said: "${spoken}"<br>`;
        
        if (matchedColors.length > 0) {
          resultDiv.innerHTML += `<span class="correct">Correct: ${matchedColors.join(", ")}</span><br>`;
        }
        
        // Find colors that weren't matched
        const unmatchedColors = currentColors.filter(color => !matchedColors.includes(color));
        if (unmatchedColors.length > 0) {
          resultDiv.innerHTML += `<span class="incorrect">Missed: ${unmatchedColors.join(", ")}</span>`;
        }
      };

      recognition.onerror = (event) => {
        document.getElementById("spoken-result").textContent = `Error: ${event.error}`;
      };

      recognition.start();
    }
    
    function updateStats() {
      document.getElementById("correct-count").textContent = correctCount;
      document.getElementById("incorrect-count").textContent = incorrectCount;
      
      const accuracy = totalAttempts > 0 
        ? Math.round((correctCount / totalAttempts) * 100) 
        : 0;
      document.getElementById("accuracy").textContent = `${accuracy}%`;
    }
  </script>
</body>
</html>
